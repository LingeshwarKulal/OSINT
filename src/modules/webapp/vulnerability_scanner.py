"""
Vulnerability Scanner Module
Comprehensive web application vulnerability detection
"""

import requests
import concurrent.futures
from typing import List, Dict
from urllib.parse import urlparse, urljoin
import logging
from bs4 import BeautifulSoup
from rich.console import Console
from rich.table import Table
from src.core.utils import save_json

console = Console()
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Web application vulnerability scanner"""
    
    def __init__(self, url: str, threads: int = 5, verbose: bool = False):
        self.url = url
        self.threads = threads
        self.verbose = verbose
        self.vulnerabilities: List[Dict] = []
        
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def _check_http_headers(self) -> List[Dict]:
        """Check for missing security headers"""
        vulns = []
        
        try:
            response = self.session.get(self.url, timeout=10)
            headers = response.headers
            
            # Security headers to check
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header (Clickjacking vulnerability)',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing CSP header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulns.append({
                        'type': 'Security Header',
                        'severity': 'Low',
                        'description': description,
                        'url': self.url
                    })
            
            # Check for sensitive information disclosure
            if 'Server' in headers:
                vulns.append({
                    'type': 'Information Disclosure',
                    'severity': 'Info',
                    'description': f'Server header reveals: {headers["Server"]}',
                    'url': self.url
                })
            
            if 'X-Powered-By' in headers:
                vulns.append({
                    'type': 'Information Disclosure',
                    'severity': 'Info',
                    'description': f'X-Powered-By header reveals: {headers["X-Powered-By"]}',
                    'url': self.url
                })
        
        except Exception as e:
            logger.error(f"Error checking headers: {e}")
        
        return vulns
    
    def _check_ssl_tls(self) -> List[Dict]:
        """Check SSL/TLS configuration"""
        vulns = []
        
        parsed = urlparse(self.url)
        if parsed.scheme == 'http':
            vulns.append({
                'type': 'SSL/TLS',
                'severity': 'Medium',
                'description': 'Website does not use HTTPS',
                'url': self.url
            })
        
        return vulns
    
    def _check_directory_listing(self) -> List[Dict]:
        """Check for directory listing"""
        vulns = []
        
        common_dirs = [
            '/admin/', '/backup/', '/uploads/', '/images/',
            '/css/', '/js/', '/tmp/', '/temp/', '/logs/'
        ]
        
        for directory in common_dirs:
            try:
                url = urljoin(self.url, directory)
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    if 'Index of' in response.text or 'Directory listing' in response.text:
                        vulns.append({
                            'type': 'Directory Listing',
                            'severity': 'Medium',
                            'description': f'Directory listing enabled at {directory}',
                            'url': url
                        })
            except:
                pass
        
        return vulns
    
    def _check_common_files(self) -> List[Dict]:
        """Check for common sensitive files"""
        vulns = []
        
        sensitive_files = [
            '/.git/config', '/.env', '/wp-config.php.bak', '/config.php.bak',
            '/.DS_Store', '/phpinfo.php', '/info.php', '/test.php',
            '/backup.sql', '/database.sql', '/.htaccess', '/web.config',
            '/robots.txt', '/.well-known/security.txt'
        ]
        
        for file_path in sensitive_files:
            try:
                url = urljoin(self.url, file_path)
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    vulns.append({
                        'type': 'Sensitive File Exposure',
                        'severity': 'High',
                        'description': f'Sensitive file accessible: {file_path}',
                        'url': url
                    })
            except:
                pass
        
        return vulns
    
    def _check_cors(self) -> List[Dict]:
        """Check CORS configuration"""
        vulns = []
        
        try:
            headers = {'Origin': 'https://evil.com'}
            response = self.session.get(self.url, headers=headers, timeout=10)
            
            if 'Access-Control-Allow-Origin' in response.headers:
                acao = response.headers['Access-Control-Allow-Origin']
                
                if acao == '*':
                    vulns.append({
                        'type': 'CORS Misconfiguration',
                        'severity': 'Medium',
                        'description': 'CORS allows any origin (*)',
                        'url': self.url
                    })
                elif acao == 'https://evil.com':
                    vulns.append({
                        'type': 'CORS Misconfiguration',
                        'severity': 'High',
                        'description': 'CORS reflects arbitrary origins',
                        'url': self.url
                    })
        except Exception as e:
            logger.error(f"Error checking CORS: {e}")
        
        return vulns
    
    def _check_forms(self) -> List[Dict]:
        """Check forms for potential vulnerabilities"""
        vulns = []
        
        try:
            response = self.session.get(self.url, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                # Check for CSRF protection
                csrf_found = False
                for input_field in form.find_all('input'):
                    name = input_field.get('name', '').lower()
                    if 'csrf' in name or 'token' in name:
                        csrf_found = True
                        break
                
                if not csrf_found:
                    action = form.get('action', 'current page')
                    vulns.append({
                        'type': 'CSRF',
                        'severity': 'Medium',
                        'description': f'Form without CSRF protection: {action}',
                        'url': self.url
                    })
                
                # Check for autocomplete on password fields
                password_fields = form.find_all('input', {'type': 'password'})
                for field in password_fields:
                    if field.get('autocomplete') != 'off':
                        vulns.append({
                            'type': 'Security Misconfiguration',
                            'severity': 'Low',
                            'description': 'Password field allows autocomplete',
                            'url': self.url
                        })
        
        except Exception as e:
            logger.error(f"Error checking forms: {e}")
        
        return vulns
    
    def scan(self, scan_type: str = 'full') -> List[Dict]:
        """Run vulnerability scan"""
        console.print(f"[bold cyan]Starting vulnerability scan: {self.url}[/bold cyan]\n")
        
        scan_functions = []
        
        if scan_type == 'quick':
            scan_functions = [
                self._check_http_headers,
                self._check_ssl_tls
            ]
        elif scan_type == 'full':
            scan_functions = [
                self._check_http_headers,
                self._check_ssl_tls,
                self._check_directory_listing,
                self._check_common_files,
                self._check_cors,
                self._check_forms
            ]
        
        # Run scans
        for func in scan_functions:
            console.print(f"[cyan]Running: {func.__name__.replace('_', ' ').title()}[/cyan]")
            vulns = func()
            self.vulnerabilities.extend(vulns)
        
        return self.vulnerabilities
    
    def display_results(self, results: List[Dict]):
        """Display scan results"""
        if not results:
            console.print("\n[green]✓ No vulnerabilities found![/green]")
            return
        
        # Group by severity
        severity_groups = {}
        for vuln in results:
            severity = vuln['severity']
            if severity not in severity_groups:
                severity_groups[severity] = []
            severity_groups[severity].append(vuln)
        
        # Display by severity
        severity_order = ['Critical', 'High', 'Medium', 'Low', 'Info']
        
        for severity in severity_order:
            if severity in severity_groups:
                vulns = severity_groups[severity]
                
                # Color based on severity
                color = {
                    'Critical': 'red',
                    'High': 'red',
                    'Medium': 'yellow',
                    'Low': 'cyan',
                    'Info': 'blue'
                }.get(severity, 'white')
                
                console.print(f"\n[bold {color}]{severity} Severity ({len(vulns)})[/bold {color}]")
                
                for vuln in vulns:
                    console.print(f"  [{color}]•[/{color}] {vuln['type']}: {vuln['description']}")
                    if self.verbose:
                        console.print(f"    URL: {vuln['url']}")
        
        # Summary
        console.print(f"\n[bold]Total vulnerabilities found: {len(results)}[/bold]")
    
    def save_results(self, results: List[Dict], filename: str):
        """Save results to file"""
        data = {
            'target': self.url,
            'total_vulnerabilities': len(results),
            'vulnerabilities': results,
            'scan_date': str(__import__('datetime').datetime.now())
        }
        
        save_json(data, filename)
